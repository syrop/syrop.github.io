---
layout: post
title:  "Repository pattern and testing (previev)"
date:   2019-07-12 05:01:00 +0200
categories: jekyll update
---

This article shows how to test a repository in a relatively large project.

## The project

The project used in this article is [Victor Events][events].

## Lessons learned

# Don't use circular dependencies

In the project I used two repositories that depended on each other, `Comms` and `Events`. Each had the other passed in the constructor, which lead to the program hanging up.

I solved it by using lazy initialization and passing one of the dependencies in a parameter of a function that would be only invoked later:

```kotlin
class EventSyncWorker(context: Context, params: WorkerParameters) :
        CoroutineWorker(context, params), SyncWorker {

    private val events by instance<Events>()
    private val comms by instance<Comms>()

    override suspend fun doWork() = syncCoroutineScope {
        try {
            events fromComms comms
        }
        catch (e: FirebaseFirestoreException) {}
        Result.success()
    }

   ...

}
```

The problem is solved when dependencies are lazily retrieved into fields, as opposed to injected in the constructor. I was using this convention before I decided to test my project.

I moved on to construction injection when I decided to test my repositories. In this way, however, I gave up lazy initialization.

I could still pass [`Lazy`][lazy] in the constructor, and have the best of both worlds, but I decided I did not need a circular dependency in the first place, so I decided to move lazy initialization to another class, and pass the dependency `comms` into `Events` in a parameter of a function using it:

```kotlin
events fromComms comms
```

The discussed change is visible in my [commit][commit-one].

# @Dao as an abstract class

Here is the code I use for my `@Dao`:

```kotlin
@Dao
abstract class EventsDao {

    open suspend infix fun add(event: Event) = insert(Event.Entity(event))
    suspend infix fun addAll(events: Collection<Event>) = insertAll(events.map { Event.Entity(it) })
    suspend infix fun delete(event: Event) = delete(Event.Entity(event))
    suspend inline fun getAllValues() = getAll().map { it.value() }

    @Query("select * from ${EventsDb.EVENT_TABLE}")
    abstract suspend fun getAll(): List<Event.Entity>

    @Insert
    abstract suspend fun insertAll(events: Collection<Event.Entity>)

    @Insert
    abstract suspend fun insert(event: Event.Entity)

    @Delete
    abstract suspend fun delete(event: Event.Entity)

    @Query("delete from ${EventsDb.EVENT_TABLE}")
    abstract suspend fun clear()
}

```

Because I use `abstract class` istead of `interface` I can add my own functions. (Notice the `open` function used by Mockito). Previously I was using an `interface` with a few added extension functions, but these do not work well with Mockito. Mockito doesn't mock extension function, because it sees them as static functions belonging to another class.

I was trying to use an interface with default implementations, but these do not work in Java code generated by Room. I would receive an error message:

```
error: EventsDao_Impl is not abstract and does not override abstract method getAllValues(Continuation<? super List<Event>>) in EventsDao
```

I decided to stick to using an abstract class, even though the [documentation][dao-doco] proposes the use of interface. I have noticed no disadvantages of the construction I use.

The change may be seen in the [commit][commit-one].

## The test

This is the test. It may be further described in a final version of the article.

Please note the annotation *preview* in the title of the present version. When it is removed, the reader may expect a more detailed explanation.

```kotlin
@ExperimentalCoroutinesApi
@ObsoleteCoroutinesApi
class EventsTest {

    private lateinit var fsReader: FsReader
    private lateinit var fsWriter: FsWriter
    private lateinit var eventsDao: EventsDao

    private val mainThreadSurrogate = newSingleThreadContext("UI thread")

    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setUp() {
        Dispatchers.setMain(mainThreadSurrogate)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
        mainThreadSurrogate.close()
    }

    @Before
    fun mockConstructorParameters() {
        fsReader = mock(FsReader::class.java)
        fsWriter = mock(FsWriter::class.java)
        eventsDao = mock(EventsDao::class.java)
    }

    @Test
    fun testAdd() = runBlockingTest {
        val events = Events(fsReader, fsWriter, eventsDao)
        val event = Event.creationEvent
        @Suppress("UNCHECKED_CAST")
        val observer = mock(Observer::class.java) as Observer<Unit>
        events.updatedLiveData().observeForever(observer)
        events.add(event)
        verify(fsWriter).add(event)
        verify(eventsDao).add(event)
        verify(observer).onChanged(Unit)
    }
}
```

[events]: https://github.com/syrop/Victor-Events
[commit-one]: https://github.com/syrop/Victor-Events/commit/740f99922ca5a6c81e366a84c8c04ff30e8f6d82
[dao-doco]: https://developer.android.com/training/data-storage/room/accessing-data.html
[lazy]: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-lazy/index.html

