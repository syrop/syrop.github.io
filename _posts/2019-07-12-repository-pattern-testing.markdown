---
layout: post
title:  "Repository pattern and testing (previev)"
date:   2019-07-12 05:01:00 +0200
categories: jekyll update
---

This article shows how to test a repository in a relatively large project.

## The project

The project used in this article is [Victor Events][events].

## Lessons learned

# Don't use circular dependencies

In the project I used two repositories that depended on each other, `Comms` and `Events`. Each had the other passed in the constructor, which lead to the program hanging up.

I solved it by using lazy initialization and passing one of the dependencies in a parameter of a function that would be only invoked later:

```kotlin
class EventSyncWorker(context: Context, params: WorkerParameters) :
        CoroutineWorker(context, params), SyncWorker {

    private val events by instance<Events>()
    private val comms by instance<Comms>()

    override suspend fun doWork() = syncCoroutineScope {
        try {
            events fromComms comms
        }
        catch (e: FirebaseFirestoreException) {}
        Result.success()
    }

   ...

}
```

The problem is solved when dependencies are lazily retrieved into fields, as opposed to injected in the constructor. I was using this convention before I decided to test my project.

I moved on to construction injection when I decided to test my repositories. In this way, however, I gave up lazy initialization.

I could still pass [`Lazy`][lazy] in the constructor, and have the best of both worlds, but I decided I did not need a circular dependency in the first place, so I decided to move lazy initialization to another class, and pass the dependency `comms` into `Events` in a parameter of a function using it:

```kotlin
events fromComms comms
```

The discussed change is visible in my [commit][commit-one].

# @Dao as an abstract class

Here is the code I use for my `@Dao`:

```kotlin
@Dao
abstract class EventsDao {

    open suspend infix fun add(event: Event) = insert(Event.Entity(event))
    suspend infix fun addAll(events: Collection<Event>) = insertAll(events.map { Event.Entity(it) })
    suspend infix fun delete(event: Event) = delete(Event.Entity(event))
    suspend inline fun getAllValues() = getAll().map { it.value() }

    @Query("select * from ${EventsDb.EVENT_TABLE}")
    abstract suspend fun getAll(): List<Event.Entity>

    @Insert
    abstract suspend fun insertAll(events: Collection<Event.Entity>)

    @Insert
    abstract suspend fun insert(event: Event.Entity)

    @Delete
    abstract suspend fun delete(event: Event.Entity)

    @Query("delete from ${EventsDb.EVENT_TABLE}")
    abstract suspend fun clear()
}

```

Because I use `abstract class` istead of `interface` I can add my own functions. (Notice the `open` function used by Mockito). Previously I was using an `interface` with a few added extension functions, but these do not work well with Mockito. Mockito doesn't mock extension function, because it sees them as static functions belonging to another class.

I was trying to use an interface with default implementations, but these do not work in Java code generated by Room. I would receive an error message:

```
error: EventsDao_Impl is not abstract and does not override abstract method getAllValues(Continuation<? super List<Event>>) in EventsDao
```

I decided to stick to using an abstract class, even though the [documentation][dao-doco] proposes the use of interface. I have noticed no disadvantages of the construction I use.

The change may be seen in the [commit][commit-one].

## Listening to changes

In [another article][liverepository] in this blog, in the section 'Observable repository', I described a design pattern I use for different observers to be notifien when there has been a change in the repository. I call that pattern `LiveRepository`.

This is the code I was using before I performed a refactoring, which I will discuss shortly. **Please do not use it**:

```kotlin
abstract class LiveRepository {

    private val liveData = MutableLiveData<Unit>()

    private val channel = BroadcastChannel<Unit>(Channel.CONFLATED)

    protected fun notifyDataSetChanged() {
        liveData.postValue(Unit)
        channel.sendBlocking(Unit)
    }

    infix fun vm(vm: ViewModel) = { block: () -> Unit ->
        vm.viewModelScope.launch { this@LiveRepository(block) }
    }

    operator fun plus(owner: LifecycleOwner): HotData<Unit> =
            DefaultHotData(liveData, owner)

    suspend operator fun invoke(block: () -> Unit) {
        with (channel.openSubscription()) {
            if (!isEmpty) receive()
            try {
                while (true) {
                    receive()
                    block()
                }
            } finally { cancel() }
        }
    }
}
```

The code above tries to solve the following problem:

There are two ways in which something may be observed. One is aware of `Lifecycle`, and the other is aware of `CoroutineScope`.

Things observed in `Activity` and `Fragment` should probably use `LiveData`, but beceause `Lifecycle` is not present in `ViewModel`, but `viewModelScope` is, the developer, apart from returning an instance of `LiveData`, should provide a mechanism that is canceled simultaneously with the surrounding `CoroutineScope`.


In the above code, I accomodated for the first case by implementing the operator `plus()` that combines `LiveData` with `LifeCycle`, so that it may be observed by an outside code. The latter case is addressed by the suspend operator `invoke()`, which runs a block of code on each update, as long as the `CoroutineScope` it runs in is not canceled.

The DSL I used in the above code is discussed in a [dedicated article][dsl-article] in this blog. Please note that at present, I **do not recommend** using it.

Instead of the above, I currently suggest the form presented below, and introduced in a specific [commit][commit-two]:

```kotlin
abstract class LiveRepository {

    private val broadcastChannel = BroadcastChannel<Unit>(Channel.CONFLATED)

    protected fun notifyDataSetChanged() {
        broadcastChannel.sendBlocking(Unit)
    }

    fun updatedLiveData(scope: CoroutineScope) =
        updatedLiveData(scope.coroutineContext)

    fun updatedLiveData(context: CoroutineContext = EmptyCoroutineContext) =
            liveData(context) {
                with (broadcastChannel.openSubscription()) {
                    try {
                        while (true) {
                            emit(receive())
                        }
                    }
                    finally {
                        cancel()
                    }
                }
            }
        }

```

The above code takes advantage of my favorite function [`liveData()`][livedata], which wraps `CoroutineScope` handling in `LiveData`.

The function currently is in its alpha state, but I believe it is good to use it. By doing so, the developer takes advantage of code that is probably already tested by thousands of other developers.

By avoiding the use of alpha dependencies, and choosing to use one's own implementations, the developer is forced to use a code that is only tested by themselves, and perhaps a few of the other members of their team, and has to maintain it.

By using the libraries provided by Google, even though they are in alpha stage now, the developer capitalizes of the maintenance performed by the company, and the function itself will probably soon reach a stable release.

The required dependencies for [`liveData()`][livedata] are listed in Google's [documentation][livedata-dependencies].

## The test

This is the test. It may be further described in a final version of the article.

Please note the annotation *preview* in the title of the present version. When it is removed, the reader may expect a more detailed explanation.

```kotlin
@ExperimentalCoroutinesApi
@ObsoleteCoroutinesApi
class EventsTest {

    private lateinit var fsReader: FsReader
    private lateinit var fsWriter: FsWriter
    private lateinit var eventsDao: EventsDao

    private val mainThreadSurrogate = newSingleThreadContext("UI thread")

    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()

    @Before
    fun setUp() {
        Dispatchers.setMain(mainThreadSurrogate)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
        mainThreadSurrogate.close()
    }

    @Before
    fun mockConstructorParameters() {
        fsReader = mock(FsReader::class.java)
        fsWriter = mock(FsWriter::class.java)
        eventsDao = mock(EventsDao::class.java)
    }

    @Test
    fun testAdd() = runBlockingTest {
        val events = Events(fsReader, fsWriter, eventsDao)
        val event = Event.creationEvent
        @Suppress("UNCHECKED_CAST")
        val observer = mock(Observer::class.java) as Observer<Unit>
        events.updatedLiveData().observeForever(observer)
        events.add(event)
        verify(fsWriter).add(event)
        verify(eventsDao).add(event)
        verify(observer).onChanged(Unit)
    }
}
```

[events]: https://github.com/syrop/Victor-Events
[commit-one]: https://github.com/syrop/Victor-Events/commit/740f99922ca5a6c81e366a84c8c04ff30e8f6d82
[dao-doco]: https://developer.android.com/training/data-storage/room/accessing-data.html
[lazy]: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-lazy/index.html
[liverepository-article]: https://syrop.github.io/jekyll/update/2019/04/27/refreshing-your-data.html
[dsl-article]: https://syrop.github.io/jekyll/update/2019/04/30/repository-and-DSL.html
[commit-two]: https://github.com/syrop/Victor-Events/commit/898a34fffa80131dc6819bb2bd84061c65dc8b07
[livedata]: https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#liveData(kotlin.coroutines.CoroutineContext,%20kotlin.Long,%20kotlin.coroutines.SuspendFunction1)
[livedata-dependencies]: https://developer.android.com/topic/libraries/architecture/coroutines
