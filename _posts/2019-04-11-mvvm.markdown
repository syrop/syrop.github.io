---
layout: post
title:  "MVP (design pattern)"
date:   2019-04-11 2:01:00 +0200
categories: jekyll update
---

During my last job interview I was asked about the [MVP pattern][mvp].

## Why this question?

I think there is no point in using the MVP pattern in production. Why not just observe the viewmodel?

Still, it does makes plenty of sense to ask this particular question during a job interview. If you do not know any viable alternative to MVVM, then how do you know *why* you are using the MVVM pattern in the first place?

Please note I am not very good in implementing the MVP. I only wrote this article, and the example project contained herein, as a refactoring of another project, and only to prove that I - at least to some extent - understand the difference.

MVP may have way more virtue than I currently give it credit for; I just don't understand its most relevant applications.

## The project

The project used in this article is [MVP][mvp-project]. It is a refactoring of [MVVM][mvvm-project].

Please read the [previous article][mvvm-article] to understand the original architecture.

As I was refactoring the project, I changed the package name from `pl.org.seva.mvvm`, deleted the package `viewmodel` and created a new package `presenter`. In the new version of the project I do not use the Android's class [`ViewModel`][viewmodel] nor [`LiveData`][livedata] at all.

## The presenter

This is the code of the presenter that subscribes to the RxJava's `Observable` described in the [previous article][mvvm-article], interacts directly with the view and handles the lifecycle:

{% highlight kotlin %}

class ActivityPresenter(
        private val desc: (String) -> Unit,
        private val conf: (Int) -> Unit) {

    fun present(act: ActivityDesc) {
        desc(act.desc)
        conf(act.conf)
    }

    @Suppress("unused")
    class Builder(private val owner: LifecycleOwner) {
        lateinit var presentDesc: (String) -> Unit
        lateinit var presentConf: (Int) -> Unit

        fun build() {
            val presenter = ActivityPresenter(presentDesc, presentConf)
            val lifecycle = owner.lifecycle
            var last: ActivityDesc? = null

            val d = ar.observable
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe { act ->
                        if (lifecycle.currentState == Lifecycle.State.RESUMED) {
                            presenter.present(act)
                            last = null
                        }
                        else {
                            last = act
                        }
                    }
            lifecycle.addObserver(object : LifecycleObserver {
                @OnLifecycleEvent(value = Lifecycle.Event.ON_RESUME)
                fun presentLast() {
                    last?.let { presenter.present(it) }
                }

                @OnLifecycleEvent(value = Lifecycle.Event.ON_DESTROY)
                fun dispose() {
                    d.dispose()
                }
            })
        }
    }

    companion object {
        fun build(owner: LifecycleOwner, block: Builder.() -> Unit) = Builder(owner).apply(block).build()
    }
}

{% endhighlight %}

The presenter really only needs to keep instances to lambdas that are a part of the view. It doesn't need to know more about the view:

{% highlight kotlin %}

class ActivityPresenter(
        private val desc: (String) -> Unit,
        private val conf: (Int) -> Unit)

{% endhighlight %}

What the `build()` function does is the following: it collecs the lifecycle from the `LifecycleObserver`, creates a `Disposable` by calling `subscribe()` on the `Observable`, and eventually disposes it.

The crucial line is:

{% highlight kotlin %}

.observeOn(AndroidSchedulers.mainThread())

{% endhighlight %}

Because the presenter deals with the view, it can only do so on Android's main thread.

If the view happens to be paused, the above code will store the value last generated by the `Observable`, but it won't present it until the view is resumed. Notice this line:

{% highlight kotlin %}

last?.let { presenter.present(it) }

{% endhighlight %}

I cannot replace it with:

{% highlight kotlin %}

if (last != null) {
    presenter.present(last!!)
}

{% endhighlight %}

The value of `last` is updated from another thread, so it can be changed to `null` even **after** the check `if (last != null)` has already been made. Calling `last?let` captures the most up-to-date value of `last`, and if it is not `null` then executes the block.

## In the Fragment

This is all it takes to create an instance of the presenter:

{% highlight kotlin %}

ActivityPresenter.build(this) {
    presentDesc = { activity_desc.text = it }
    presentConf = { activity_conf.text = it.toString() }
}

{% endhighlight %}

Calling `build()` actually subscribes to the RxJava's `Observable` and starts observing the lifecycle of the `Fragment` the code is called from. Altertatively, I could create the instance of the presenter in one function, for example `build()`, and then create another function, for example `observe()`, to start observing the lifecycle. Creating one extra function would promote [separation of concerns][soc], but I decided to stick to only one function in order to promote a more concise code. Your particular architecture choice is up to you.

## Testing

Testing is not different at all from the techique discussed in the [previous article][mvvm-article]. Because testing doesn't depend on choice of architecture (MVVM or MVP) you can use identical code.

Please note, though, that because I changed the package name, you also have to change the `testInstrumentationRunner` in your module-level `build.gradle`:

{% highlight groovy %}

testInstrumentationRunner 'pl.org.seva.mvp.mock.MockTestRunner'

{% endhighlight %}

## Conclusion

In this article I described the way in which you could refactor the MVVM architecture - described in the [previous article][mvvm-article] - to the MVP alternative.

I do not exactly understand the advantages of one over the other, but I do not personally fancy handling the lifecycle manually, so I will stick to the MVVM, even thought I hope to have proven that switching from one to the other is trivial.


[mvp]: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter
[mvp-project]: https://github.com/syrop/MVP
[mvvm-project]: https://github.com/syrop/MVVM
[mvvm-article]: https://syrop.github.io/jekyll/update/2019/04/06/mvvm.html
[viewmodel]: https://developer.android.com/reference/android/arch/lifecycle/ViewModel
[livedata]: https://developer.android.com/reference/androidx/lifecycle/LiveData
[soc]: https://en.wikipedia.org/wiki/Separation_of_concerns



